function [ofc, vstr, hipp, dt, hippflag, decimatefactor, detrend, diffdata] = prepCSCs_new
%2014-09-10. JJS. Loads and prepares the ofc and vstr CSC files that are
%specified as 'good' in the keys file for analysis of granger causality for
%a single session.
%2020-04-06. JJS. Modifications to work w/ MvdMlab codeset.

decimatefactor = 2; % decimates by taking every nth sample
filtorder = 8;
detrend = 1;
diffdata = 0;
doRestrict = 1;
% process_varargin(varargin);

hippflag = 0;
tic
EvalKeys;
% Load the CSCs
cfg_ofc.fc = {ExpKeys.OFCcsc};
cfg_ofc.VoltageConvFactor = 10^6;
[ofc] = LoadCSC(cfg_ofc);

cfg_vstr.fc = {ExpKeys.VSTRcsc}; 
cfg_vstr.VoltageConvFactor = 10^6;
[vstr] = LoadCSC(cfg_vstr); 

if strcmp('NaN', ExpKeys.HIPPcsc) == 0 && hippflag == 1;
    cfg_hipp.fc = ExpKeys.HIPPcsc;
    [hipp] = LoadCSC(cfg_hipp); 
end

% restrict to time on track
if doRestrict == 1;
%     ofc = ofc.restrict(ExpKeys.TimeOnTrack, ExpKeys.TimeOffTrack); Tofc = ofc.range;
%     vstr = vstr.restrict(ExpKeys.TimeOnTrack, ExpKeys.TimeOffTrack); Tvstr = vstr.range;
    
    ofc = restrict(ofc, ExpKeys.TimeOnTrack, ExpKeys.TimeOffTrack);
    vstr = restrict(vstr, ExpKeys.TimeOnTrack, ExpKeys.TimeOffTrack);
    
else
    Tofc = ofc.tvec;
    Tvstr = vstr.range;
end

if doRestrict == 1 && hippflag == 1;
    hipp = hipp.restrict(ExpKeys.TimeOnTrack, ExpKeys.TimeOffTrack); Thipp = hipp.range;
    assert(length(hipp.data)==length(ofc.data)); assert(hipp.dt == ofc.dt);
else
%     Thipp = hipp.range;
    hipp = [];
end
assert(length(ofc.data)==length(vstr.data));
assert(median(diff(ofc.tvec)) == median(diff(vstr.tvec)));

% added 2014-09-15.
% downsample the data (normal sampling rate is approx. 2kHz, which is more than I need.
% y=decimate(x,r);
% "The decimated vector y is r times shorter in length than the input vector x."
%  By default, decimate employs an eighth-order lowpass Chebyshev Type I filter with a cutoff frequency of 0.8*(Fs/2)/r. It filters the input sequence in both the forward and reverse directions to remove all phase distortion, effectively doubling the filter order.
if decimatefactor > 0;
    disp('decimating data'); disp(strcat('r =',num2str(decimatefactor)));
    ofcdata = decimate(ofc.D(2:end-1), decimatefactor, filtorder);
    Tofc = Tofc(2:decimatefactor:end-1);
    ofc = tsd(Tofc, ofcdata);
    
    vstrdata = decimate(vstr.D(2:end-1), decimatefactor);
    Tvstr = Tvstr(2:decimatefactor:end-1);
    vstr = tsd(Tvstr, vstrdata);
    
    if hippflag == 1;
        hippdata = decimate(hipp.D(2:end-1), decimatefactor, filtorder);
        Thipp = Thipp(2:decimatefactor:end-1);
        hipp = tsd(Thipp, hippdata);
        assert(length(hipp.data)==length(ofc.data));
    end
    assert(length(ofc.data)==length(vstr.data));
    assert(length(ofc.range)==length(vstr.range));
end

% remove dc shifts in voltage
if detrend == 1;
    ofcdata=locdetrend(ofc.data, 1/ofc.dt, [1 0.5]);
    vstrdata=locdetrend(vstr.data, 1/vstr.dt, [1 0.5]);
    ofc = tsd(ofc.range, ofcdata);
    vstr = tsd(vstr.range, vstrdata);
    if hippflag == 1;
        hippdata = locdetrend(hipp.data, 1/hipp.dt, [1 0.5]);
        hipp = tsd(hipp.range, hippdata);
    end
end

if diffdata == 1;
    % First Order Differencing
    ofc = tsd(ofc.T(1:end-1), diff(ofc.D));
    vstr = tsd(vstr.T(1:end-1), diff(vstr.D));
end

dt = 1/ofc.dt;
assert((1/ofc.dt)==(1/vstr.dt))

if sum(isnan(ofc.D))>0;
    warning('1 or more NaNs in OFC data');
end
if sum(isnan(vstr.D))>0;
    warning('1 or more NaNs in VSTR data');
end
if hippflag == 1;
    if sum(isnan(hipp.D))>0;
        warning('1 or more NaNs in HIPP data');
    end
end

toc

end
